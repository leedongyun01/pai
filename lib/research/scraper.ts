import { ResearchResult, ResearchResultSchema } from "./types";
import { SearchError } from "./engine";
import { isMockMode } from "../utils/ai";

/**
 * Searches the web using Tavily API and extracts page content
 * @param query The search query string
 * @param options Configuration for search depth and result count
 */
export async function searchAndExtract(
  query: string,
  options: { searchDepth?: "basic" | "advanced"; maxResults?: number } = {}
): Promise<{ results: ResearchResult[]; answer?: string }> {
  const apiKey = process.env.TAVILY_API_KEY;

  if (isMockMode() || !apiKey || apiKey === "your_api_key_here") {
    console.log("Mock mode enabled or Tavily key missing. Returning mock search results.");
    return {
      results: [
        {
          url: "https://example.com/mock-result-1",
          title: "Mock Search Result 1 for: " + query,
          content: "This is a mock search result content. It simulates a real web page found by Tavily. The topic is " + query + ". In a real scenario, this would contain scraped text from a website.",
          queryMatch: query,
          timestamp: new Date().toISOString(),
          score: 0.95,
        },
        {
          url: "https://example.com/mock-result-2",
          title: "Mock Search Result 2 for: " + query,
          content: "Another mock result. This demonstrates that the system can handle multiple results in mock mode. Quick Scan should use these snippets to generate a summary if the direct answer is missing.",
          queryMatch: query,
          timestamp: new Date().toISOString(),
          score: 0.88,
        },
        {
          url: "https://example.com/mock-result-3",
          title: "Mock Search Result 3",
          content: "Final mock result content. This ensures we have enough data to trigger the fallback summary generation in the synthesizer.",
          queryMatch: query,
          timestamp: new Date().toISOString(),
          score: 0.82,
        }
      ],
      answer: "This is a mock answer generated by the system because Tavily is unavailable. It provides a direct summary of the mock results."
    };
  }

  const MAX_RETRIES = 2;
  const TIMEOUT_MS = 15000;

  let lastError: any;
  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

      const response = await fetch("https://api.tavily.com/search", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        signal: controller.signal,
        body: JSON.stringify({
          api_key: apiKey,
          query: options.searchDepth === "basic" ? `${query} (답변은 한국어로, 아주 구체적이고 상세하게 길게 작성해줘)` : query,
          search_depth: options.searchDepth || "basic",
          include_answer: true, 
          include_images: false,
          include_raw_content: false, 
          max_results: options.maxResults || 5,
        }),
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        if (response.status >= 500 && attempt < MAX_RETRIES) {
          continue; // Retry on 5xx
        }
        throw new SearchError(`Tavily API error: ${response.status} ${response.statusText}`, response.status);
      }

      const data = await response.json();
      const results = (data.results || [])
        .filter((res: any) => {
          const binaryExtensions = ['.pdf', '.zip', '.exe', '.dmg', '.mp4', '.mp3', '.jpg', '.png'];
          return !binaryExtensions.some(ext => res.url.toLowerCase().endsWith(ext));
        })
        .map((res: any) => {
          const rawContent = res.content || "";
          const cleanedContent = rawContent.replace(/\s+/g, ' ').trim();
          return {
            url: res.url,
            title: res.title || "No Title",
            content: cleanedContent,
            queryMatch: query,
            timestamp: new Date().toISOString(),
            score: res.score || 0,
          };
        });

      return { results, answer: data.answer };
    } catch (error) {
      console.warn(`Tavily search attempt ${attempt + 1} failed:`, error);
      
      // If it's the last attempt, fall back to mock data instead of failing completely
      if (attempt === MAX_RETRIES) {
         console.log("All Tavily retries failed. Falling back to mock data.");
         return {
          results: [
            {
              url: "https://fallback.com/result-1",
              title: "Fallback Result: " + query,
              content: "Search engine was unavailable. This is a fallback result to ensure the process completes.",
              queryMatch: query,
              timestamp: new Date().toISOString(),
              score: 0.9,
            },
            {
              url: "https://fallback.com/result-2",
              title: "Fallback Result: System Status",
              content: "The system encountered an error connecting to the search provider. Please check your API keys.",
              queryMatch: query,
              timestamp: new Date().toISOString(),
              score: 0.85,
            }
          ],
          answer: "The search engine was unavailable, so this is a generated fallback answer. Please check your internet connection or API keys."
        };
      }
      
      lastError = error;
      if (error instanceof Error && error.name === 'AbortError') {
        if (attempt < MAX_RETRIES) continue;
      }
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }

  // This part should effectively be unreachable due to the return in the catch block above,
  // but kept for type safety or unexpected flow break.
  return { results: [], answer: "Search failed." };
}
