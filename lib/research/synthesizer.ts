import { google } from "@ai-sdk/google";
import { generateObject } from "ai";
import crypto from 'node:crypto';
import { ReportSchema, ConflictSchema } from "./schemas";
import { Report, Conflict } from "./types";
import { getSession, saveSession } from "../storage/session-store";
import { SYNTHESIS_SYSTEM_PROMPT, getSynthesisUserPrompt, CONFLICT_DETECTION_PROMPT } from "./prompts";
import { ResearchSession as SessionStoreType } from "../types/session";
import { z } from "zod";
import { AI_MODELS, isMockMode } from "../utils/ai";

export class Synthesizer {
  private model = google(AI_MODELS.PRO);

  /**
   * Orchestrates the synthesis process for a given session
   */
  async synthesize(sessionId: string): Promise<Report> {
    const session = await getSession(sessionId);

    if (!session) {
      throw new Error(`Session ${sessionId} not found`);
    }

    if (!session.results || session.results.length === 0) {
      // Exception: If it's Quick Scan and we have a direct answer, proceed!
      if (session.mode === "quick_scan" && session.tavilyAnswer) {
        console.log(`No results but Tavily answer exists for quick_scan session ${sessionId}. Proceeding.`);
      } else {
        console.warn(`No research results found for session ${sessionId}. Generating empty report.`);
        const emptyReport: Report = {
          id: crypto.randomUUID(),
          sessionId: session.id,
          title: `Research Report: ${session.query}`,
          sections: [
            {
              title: "No Results Found",
              content: "The research process did not return any relevant results for your query. This could be due to a very specific topic or lack of available public information.",
              citations: [],
              subsections: []
            }
          ],
          references: [],
          metadata: {
            generatedAt: new Date().toISOString(),
            model: "none",
          },
        };

        const updatedSession: SessionStoreType = {
          ...session,
          report: emptyReport as any,
          status: "completed",
          updatedAt: new Date().toISOString(),
        };
        await saveSession(updatedSession);
        return emptyReport;
      }
    }

    const sourcesForPrompt = (session.results || []).map((r, i) => ({
      id: r.id || `source_${i}`,
      content: r.content,
      title: r.title,
    }));

    // US-MODE: Quick Scan always uses Tavily's generated answer
    if (session.mode === "quick_scan") {
      console.log(`Using Tavily's generated answer for quick_scan session ${sessionId}`);
      
      let summaryContent = session.tavilyAnswer;
      
      // Fallback: If Tavily didn't provide an answer, construct one from the search snippets
      if (!summaryContent && session.results && session.results.length > 0) {
        console.log("Tavily answer missing, generating fallback summary from snippets.");
                summaryContent = (session.results || []).slice(0, 3).map((r, i) => `**${r.title}**\n${r.content.substring(0, 300)}...`).join("\n\n");      }

      const report: Report = {
        id: crypto.randomUUID(),
        sessionId: session.id,
        title: `Research Report: ${session.query}`,
        sections: [
          {
            title: "Executive Summary",
            content: summaryContent || "No direct answer was generated by the search engine. Please refer to the search results below.",
            citations: (session.results || []).slice(0, 3).map((r, i) => r.id || `source_${i}`),
            subsections: []
          }
        ],
        references: (session.results || []).map((r, i) => ({
          ...r,
          id: r.id || `source_${i}`,
        })) as any,
        metadata: {
          generatedAt: new Date().toISOString(),
          model: "tavily-generated",
        },
      };

      const updatedSession: SessionStoreType = {
        ...session,
        report: report as any,
        status: "completed",
        updatedAt: new Date().toISOString(),
      };
      await saveSession(updatedSession);
      return report;
    }

    if (isMockMode()) {
      return this.generateFallbackReport(session);
    }

    try {
      let detectedConflicts: Conflict[] = [];

      // T019: Implement "Deep Probe" two-pass logic
      if (session.mode === "deep_probe") {
        console.log(`Performing Deep Probe synthesis for session ${sessionId}...`);
        
        // Pass 1: Conflict Detection
        const { object: conflictResults } = await generateObject({
          model: this.model,
          schema: z.object({ conflicts: z.array(ConflictSchema) }),
          system: CONFLICT_DETECTION_PROMPT,
          prompt: getSynthesisUserPrompt(session.query, sourcesForPrompt),
        });
        
        detectedConflicts = conflictResults.conflicts;
        console.log(`Detected ${detectedConflicts.length} conflicts.`);
      }

      // T009: Quick Scan or Phase 2 of Deep Probe
      const synthesisPrompt = session.mode === "deep_probe" 
        ? `${getSynthesisUserPrompt(session.query, sourcesForPrompt)}\n\nInclude the following detected conflicts in the report:\n${JSON.stringify(detectedConflicts)}`
        : getSynthesisUserPrompt(session.query, sourcesForPrompt);

      // Pass 2: Final Synthesis
      const { object: reportData } = await generateObject({
        model: this.model,
        schema: ReportSchema,
        system: SYNTHESIS_SYSTEM_PROMPT,
        prompt: synthesisPrompt,
      });

      const report: Report = {
        ...reportData,
        id: crypto.randomUUID(),
        sessionId: session.id,
              references: (session.results || []).map((r, i) => ({
                ...r,
                id: r.id || `source_${i}`,
              })) as any,
        
        metadata: {
          generatedAt: new Date().toISOString(),
          model: AI_MODELS.PRO,
        },
      };

      // Save report back to session
      const updatedSession: SessionStoreType = {
        ...session,
        report: report as any,
        status: "completed",
        updatedAt: new Date().toISOString(),
      };

      await saveSession(updatedSession);

      // T017: Add citation validity check
      this.validateCitations(report);

      return report as Report;
    } catch (error) {
      console.error("Synthesis failed, using fallback:", error);
      return this.generateFallbackReport(session);
    }
  }

  /**
   * Generates a basic report when AI synthesis is unavailable or fails.
   */
  private async generateFallbackReport(session: any): Promise<Report> {
    const fallbackReport: Report = {
      id: crypto.randomUUID(),
      sessionId: session.id,
      title: `Research Report: ${session.query}`,
      sections: [
        {
          title: "Summary of Findings",
                  content: (session.results || []).slice(0, 5).map((r: any) => `- ${r.title}: ${r.content.substring(0, 200)}...`).join("\n\n"),
                  citations: (session.results || []).slice(0, 5).map((r: any, i: number) => r.id || `source_${i}`),
                  subsections: []
                }
              ],
              references: (session.results || []).map((r: any, i: number) => ({        ...r,
        id: r.id || `source_${i}`,
      })) as any,
      metadata: {
        generatedAt: new Date().toISOString(),
        model: isMockMode() ? "mock" : "fallback-static",
      },
    };

    const updatedSession: SessionStoreType = {
      ...session,
      report: fallbackReport as any,
      status: "completed",
      updatedAt: new Date().toISOString(),
    };
    await saveSession(updatedSession);
    
    return fallbackReport;
  }

  /**
   * Validates that all citations in the report point to existing references
   */
  private validateCitations(report: Report): void {
    const validSourceIds = new Set(report.references.map((r) => (r as any).id));

    const checkSection = (section: any) => {
      for (const citationId of section.citations) {
        if (!validSourceIds.has(citationId)) {
          console.warn(`Invalid citation found: ${citationId} in section "${section.title}"`);
          // In a strict mode, we might want to throw or remove the invalid citation
        }
      }
      for (const sub of section.subsections) {
        checkSection(sub);
      }
    };

    for (const section of report.sections) {
      checkSection(section);
    }
  }
}
